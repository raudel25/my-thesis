\documentclass[12pt]{article}

\usepackage[utf8]{inputenc} % Permite escribir caracteres especiales directamente
\usepackage[spanish]{babel} % Configura el idioma a español

\title{Estrategia para la solución del SAT usando el problema del vació}
\author{Raudel Alejandro Gómez Molina}

\usepackage[lmargin=2cm,rmargin=5cm]{geometry}

\input{word-comments.tex}

\begin{document}

\maketitle

En el presente capítulo se presenta una estrategia para la solución del SAT, la cual dado un SAT, 
construye un formalismo que genera todas todas las interpretaciones que la hace verdadera la fórmula 
booleana de dicho SAT, entonces para comprobar si el SAT es satisfacible solo resta comprobar si 
el conjunto de cadenas generadas por el formalismo es no vacío.

\section{Antecedentes}

Como parte del estudio del problema SAT, se han desarrollado anteriormente en 
la Facultad de Matemática y Computación de la Universidad de La Habana 
una serie de trabajos utilizando el enfoque que se describe en este capítulo 
basado en formalismos de la teoría de lenguajes, buscando resolver 
instancias específicas del SAT, las cuales serán abordadas en las secciones del
presente capítulo. 

La idea principal que se aborda en \cite{aCFSAT} consta de tres partes: asumir que todas las variables en 
la fórmula son distintas, construir un autómata finito que reconozca cadenas de 0 y 1 hagan verdadera esa 
fórmula (asumiendo que todas las variables son distintas), y por último intersectar ese lenguaje con algún 
formalismo que garantice que todas las instancias de la misma variable tenga el mismo valor. Luego de esos 
tres pasos, se obtiene un lenguaje libre del contexto de las cadenas de 0 y 1 que satisfacen la fórmula y 
que además respeta los valores de las variables duplicadas.  Finalmente, para determinar si la fórmula es 
satisfacible o no, basta con determinar si el lenguaje es vacío. Si es vacío, no es satisfacible, si lo es, 
pues no es satisfacible. Todo el algoritmo descrito anteriormente tiene un tiempo polinomial en relación con el 
tamaño de la fórmula booleana.

En la siguiente sección se presenta un mecanismo para reconocer si una cadena de 0 y 1 satisface una fórmula booleana
(asumiendo que todas las variables son distintas).

\section{Autómata booleano}

El primer paso para el proceso descrito anteriormente es construir un autómata finito que depende de la estructura de la fórmula booleana
y verifica si una cadena de 0 y 1 satisface dicha fórmula (asumiendo que todas las variables son distintas), dicho autómata se denomina
\textbf{autómata booleano}.

La idea detrás del autómata booleano y es representar las reglas de la lógica proposicional en transiciones 
entre los estados de un autómata finito, donde cada estado del autómata representa un valor de verdad positivo o 
negativo lo cual significa que hasta ese momento (solo tomando las instancias de las variables asociadas a los 
caracteres reconocidos) la fórmula se evalúa positiva o negativa respectivamente \cite{aCFSAT}.


\section{Problema de la satisfacibilidad booleana libre del contexto}

El problema satisfacibilidad booleana libre del contexto (\textit{CF-SAT}) \cite{aCFSAT}, es una instancia específica
del SAT donde las variables donde la fórmula booleana es una fórmula booleana libre del contexto.

\paragraph{Fórmula booleana libre del contexto:} una fórmula booleana se considera libre del contexto
(\textit{CF-BF}) si para cualquier par de instancias de una variable $x_i$ y $x_j$ con $i<j$ se
cumple que si existe otra variable con instancia $x_k$ con $i<k<j$ entonces todas las instancias de esta nueva
variable ocurren entre $x_i$ y $x_j$.

Dada la definición anterior posible clasificar las instancias de cada variable en una fórmula booleana:

\begin{enumerate}
      \item \textbf{Clase libre:} a esta clase pertenecen todas las instancias de las variables que ocurren
            una única vez en la fórmula booleana.
      \item \textbf{Clase primera:} a esta clase pertenecen todas las instancias que representan la primera
            ocurrencia de una variable en la fórmula booleana (la variable debe ocurrir más de una vez).
      \item \textbf{Clase intermedia:} a esta clase pertenecen todas las instancias que no representan ni la primera, ni la última
            ocurrencia de una variable en la fórmula booleana (la variable debe ocurrir más de una vez).
      \item \textbf{Clase última:} a esta clase pertenecen todas las instancias que representan la última
            ocurrencia de una variable en la fórmula booleana (la variable debe ocurrir más de una vez).
\end{enumerate}

A continuación se describe la solución al CF-SAT.

\subsection{Solución al CF-SAT}

El orden que siguen las instancias de las variables en una CF-BF puede ser reconocido por una CFG que a su vez trae asociado
un autómata de pila, al cual de le denomina autómata de pila booleano \cite{aCFSAT}.

Para la construcción del autómata de pila booleano correspondiente a una CF-BF se toma el autómata booleano asociado
a la fórmula booleana y se le añade un mecanismo de memoria. Dicho mecanismo de memoria funciona de la siguiente manera:

\begin{itemize}
      \item Si el caracter analizado corresponde a una instancia de clase libre, dicho caracter no se almacena en la pila.
      \item Si el caracter analizado corresponde a una instancia de clase primera, dicho caracter se almacena en la pila.
      \item Si el caracter analizado corresponde a una instancia de clase intermedia, dicho caracter no se almacena en la
            pila y se comprueba que su valor sea igual al del tope de la pila.
      \item Si el caracter analizado corresponde a una instancia de clase última, dicho caracter no se almacena en la
            pila, se comprueba que su valor sea igual al del tope de la pila y se retira el valor del tope de la pila.
\end{itemize}
El autómata de pila booleano reconoce una cadena si termina en un estado final con la pila vacía.

En \cite{aCFSAT} se describe como dado un autómata de pila encontrar la CFG correspondiente y luego 
se emplea un algoritmo que permite determinar si el lenguaje generado con por la gramática es vacío o no \cite{authomataTheory}. Posteriormente 
se enuncia un algoritmo para generar todas las cadenas que pertenecen a dicha gramática. Todo el proceso anteriormente descrito tiene una complejidad de $O(n^3)$, donde $n$
es la cantidad de instancias de variables en la CF-BF.

A continuación se presenta una generalización del CF-SAT.

\subsubsection{Generalización de la solución al CF-SAT}

De manera general el algoritmo presentado en \cite{aCFSAT} puede ser generalizado a otras instancias de SAT. 
Al seguir la idea del autómata booleano (asumiendo que las instancias de las variables son distintas), solo es 
necesario emplear un formalismo que verifique que los valores de las mismas instancias de las variables sean 
iguales e interceptarlo con el autómata. Dicho formalismo debe cumplir 2 propiedades: ser cerrado bajo la intersección con lenguajes regulares y poder resolver el problema del vacío en tiempo polinomial. Por tanto si se selecciona un formalismo más general que el empleado en \cite{aCFSAT} pueden resolverse instancias más generales de SAT.

Otro resultado interesante es encontrar un algoritmo que permita generar todas las posibles cadenas que pertenecen al lenguaje generado por la intersección del autómata booleano y el formalismo seleccionado, con estas cadenas se pueden obtener los valores de verdad para cada una de las variables que satisfacen la fórmula booleana.

En las próximas secciones se presentan los problemas SAT asociados a los trabajos que siguen el enfoque 
descrito anteriormente que han sido 2: el primero usa las gramáticas de concatenación de rango simple 
para definir el orden de las variables y el segundo requiere un representación de un SAT como una 
cadena y usa esta representación para interceptar el autómata booleano con una gramática matricial 
simple que sirve de mecanismo de control para el valor de las instancias de las variables.
\section{Problema de la satisfacibilidad booleana de concatenación de rango simple}

Una secuencia de instancias de variables de longitud $n$ tiene un orden de concatenación de rango simple \cite{aSRCSAT}, 
si es posible construir una SRCG, con un tamaño polinomial en $n$, que genere el lenguaje de todas las cadenas 
$w_1w_2 \ldots w_n$, de longitud $n$ sobre el alfabeto {0,1}, tal que para todo par de instancias de variables 
($x_i$, $x_j$) que pertenezcan a la misma variable se cumple que $w_i = w_j$.

El problema de la satisfacibilidad booleana de concatenación de rango simple (\textit{SRC-SAT}) es una instancia de
SAT donde la secuencia de instancias de sus variables posee un orden de concatenación de rango simple.

\subsection{Solución al SRC-SAT}

Para la solución del SRC-SAT en \cite{aSRCSAT} se procede de manera similar a \cite{aCFSAT}, pero esta vez el autómata
booleano se intersecta con una SRCG que describe el orden de la fórmula booleana.

Luego solo queda resolver el problema del vacío para el formalismo resultante. Para esto se obtiene una CFG que representa 
el lenguaje de todas las posibles formas de generar la menor cadena en la intersección de la SRCG con el autómata booleano 
y solo queda verificar que dicha CFG sea no vacía como se muestra en \cite{aCFSAT}. La complejidad de todo este proceso es 
$O(n^k)$ donde $n$ es el número de instancias de variables en la fórmula booleana y $k$ es la aridad de la SRCG, observe 
que este algoritmo es polinomial siempre y cuando la aridad de la gramática sea constante.

El SRC-SAT constituye un paso de avance con respecto al CF-SAT ya que describe un espacio mucho más amplio de instancias de SAT
que pueden ser resueltas en un tiempo polinomial. Como se mencionó en el capítulo anterior para todo CFG existe una SRCG
equivalente

En las próximas secciones se aborda el primer enfoque para analizar la solución de un SAT de manera general, es decir, no solo
se resuelven instancias específicas como en las secciones anteriores, para ello primeramente es necesario definir la representación
de cualquier fórmula booleana en CNF como una cadena.
\section{Transformación de una fórmula booleana a una cadena}

Dada una fórmula booleana $F$ en CNF se puede definir la siguiente estructura:
$$F=X_1 \wedge X_2 \wedge \ldots \wedge X_n$$
donde cada cláusula $X_i$ es una disyunción de literales:
$$X_i=L_{i1} \vee L_{i2} \vee \ldots \vee L_{im}$$
y cada literal $L_{ij}$ es una variable booleana o su negación. En cada cláusula $X_i$ las variables que aparecen en $F$, puede tener cada una 3 estados posibles: $a$ si la variable aparece positiva, $b$ si la variable aparece negada y $c$ si la variable no pertenece a ninguno de los literales de la cláusula.

Por ejemplo la siguiente fórmula booleana en $CNF$:

$$F=(x_1 \vee x_2) \wedge (\neg x_1 \vee x_2 \vee x_3) \wedge (x_1 \vee \neg x_2 \vee x_3)$$

para la primera cláusula $x_1$ aparece positiva ($a$), $x_2$ aparece positiva ($a$) y $x_3$ no aparece $(c)$, para la segunda
$x_1$ aparece negada ($b$), $x_2$ aparece positiva ($a$) y $x_3$ aparece positiva $(a)$ y para la tercera 
$x_1$ aparece positiva ($a$), $x_2$ aparece negada ($b$) y $x_3$ aparece positiva $(a)$.

A partir de la afirmación anterior, se puede definir una cadena de símbolos $w$ que representa a la cláusula $X_i$ sobre una secuencia de variables $v_1,v_2,\ldots,v_p$ de la siguiente manera:

\begin{itemize}
      \item $w$ cuenta con exactamente $p$ símbolos.
      \item Si la variable $v_j$ aparece positiva en $X_i$, entonces el $j$-ésimo símbolo es $a$.
      \item Si la variable $v_j$ aparece negada en $X_i$, entonces el $j$-ésimo símbolo es $b$.
      \item Si la variable $v_j$ no aparece en $X_i$, entonces el $j$-ésimo símbolo es $c$.
\end{itemize}
Si se toma la secuencia de variables correspondiente a $F$, y se le aplica el procedimiento anterior a cada cláusula
se obtiene una cadena de símbolos que representa a dicha cláusula en $F$.

Si ya se tiene una representación para cada cláusula de $F$ solo resta obtener una cadena de símbolos que represente a $F$,
esto se puede lograr concatenando las cadenas de símbolos de cada cláusula de $F$ en el orden que aparecen con un separador
en este caso se eligió el símbolo $d$.

Por ejemplo la siguiente fórmula booleana en \textit{CNF}:
$$F=(x_1 \vee x_2) \wedge (\neg x_1 \vee x_2 \vee x_3) \wedge (x_1 \vee \neg x_2 \vee x_3)$$
puede ser expresada como la cadena de símbolos:
$$w=aacdbaadabad$$
tomando como secuencia de variables $x_1, x_2, x_3$.


\section{Primera aproximación a la solución del SAT usando gramáticas matriciales simples}

En \cite{aSMSAT} se propone un nuevo enfoque a los 2 problemas anteriores, el cual se basa en eliminar la restricción de la estructura de la fórmula booleana y 
en su lugar se trabaja con la transformación de la misma en una cadena.

Con esta nueva estructura se modifica el autómata booleano correspondiente a dicha fórmula para que trabaje con 
cadenas que pertenezcan al lenguaje $L^n_m=\{w^m\,|\,w\in\{0,1\} \wedge |w|=n\}$, observe que $w$ se puede 
interpretar como una asignación de valores 0 ó 1 para cada una de las variables, que representan su valor de verdad.

\subsection{Lenguaje $L^n_m$}

En \cite{aSMSAT} se define una gramática matricial simple que describe el lenguaje $L^n_m$:

$$
      G_n=(\{A_1,A_{11},\ldots A_{1m}\},\ldots,\{A_n,A_{n1},\ldots A_{nm}\},\Sigma,P,S,\Sigma)
$$
donde:
\begin{itemize}
      \item \( \Sigma \) =$\{0,1\}$.
      \item \( P \) es un conjunto finito de matrices de producciones:
            \begin{itemize}
                  \item  $[S \to A_1A_2\ldots A_n]$
                  \item  $[A_1 \to 1A_{12}, \ldots, A_n \to 1A_{n2}]$
                  \item  $[A_1 \to 0A_{12}, \ldots, A_n \to 0A_{n2}]$
                  \item  Para $2 \leq i < m$, $[A_{1i} \to 1A_{1(i+1)}, \ldots, A_{ni} \to 1A_{n(i + 1)}]$
                  \item  Para $2 \leq i < m$, $[A_{1i} \to 0A_{1(i+1)}, \ldots, A_{ni} \to 0A_{n(i + 1)}]$
                  \item  $[A_{1m} \to 1, \ldots, A_{nm} \to 1]$
                  \item  $[A_{1m} \to 0, \ldots, A_{nm} \to 0]$
            \end{itemize}
      \item \( S \) es el \textbf{símbolo inicial}.
\end{itemize}

En \cite{simpleMatrixLanguages} se demuestra que esta gramática en efecto, genera le lenguaje $L^n_m$.

Ahora solo resta interceptar esta gramática con el autómata booleano para determinar si el SAT es satisfacible.

\subsection{Intersección con el autómata booleano}

En \cite{aSMSAT} se menciona que las $n-SMG$ son cerradas bajo la intersección con lenguajes regulares, 
pero cuando se analiza la intersección del autómata con la $n-SMG$ que describe el lenguaje $L^n_m$ se 
obtiene una gramática con una cantidad de producciones exponencial en relación a la cantidad de variables 
de la fórmula booleana, lo cual impide analizar si el lenguaje resultante es vacío en un tiempo polinomial.

Este es el primer acercamiento para la solución de cualquier instancia del SAT (aunque sigue siendo una solución exponencial
en términos de complejidad computacional), en el próximo capítulo se presenta una estrategia de solución diferente
que busca otras alternativas para la solución de cualquier instancia del SAT.

\begin{thebibliography}{99}
      
      \bibitem{mainRCGBib}
      Boullier, Pierre. 
      \textit{Proposal for a Natural Language Processing Syntactic Backbone}. 
      Research Report RR-3342, INRIA, 1998. 
      
      \bibitem{propertiesRCGBib}
      Boullier, Pierre. 
      \textit{A Cubic Time Extension of Context-Free Grammars}. 
      Research Report RR-3611, INRIA, 1999. 
      
      \bibitem{simpleMatrixLanguages}
      Ibarra, Oscar H. 
      \textit{Simple matrix languages}. 
      \textit{Information and Control}, Vol. 17, No. 4, pp. 359-394, 1970. 
      
      \bibitem{globalIndexLanguages}
      Castaño, José M. 
      \textit{Global Index Languages}. 
      Ph.D. Thesis, The Faculty of the Graduate School of Arts and Sciences, Brandeis University, 2004.
      
      \bibitem{authomataTheory}
      Hopcroft, John E., Motwani, Rajeev, y Ullman, Jeffrey D. 
      \textit{Introduction to Automata Theory, Languages, and Computation}. 
      3ª edición, Addison-Wesley, 2006. ISBN: 9780321455369.
      
      \bibitem{aCFSAT}
      Fernández Arias, Alina. 
      \textit{El problema de la satisfacibilidad booleana libre del contexto}. 
      Facultad de Matemática y Computación, Universidad de La Habana, 2007.
      
      \bibitem{aSRCSAT}
      Aguilera López, Manuel. 
      \textit{Problema de la Satisfacibilidad Booleana de Concatenación de Rango Simple}. 
      Facultad de Matemática y Computación, Universidad de La Habana, 2016.
      
      \bibitem{aSMSAT}
      Rodríguez Salgado, José Jorge. 
      \textit{Gramáticas Matriciales Simples. Primera aproximación para una solución al problema SAT}. 
      Facultad de Matemática y Computación, Universidad de La Habana, 2019.
      
\end{thebibliography}




\end{document}