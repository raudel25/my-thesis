\documentclass[12pt]{article}

\usepackage[utf8]{inputenc} % Permite escribir caracteres especiales directamente
\usepackage[spanish]{babel} % Configura el idioma a español

\usepackage{amsmath}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage[lmargin=2cm,rmargin=5cm]{geometry}
\usepackage{multicol}

\usepackage{amsthm}
\newtheorem{definition}{Definición}


\input{word-comments.tex}




\title{Gramáticas de concatenación de rango}
\author{Raudel Alejandro Gómez Molina}

\begin{document}

\maketitle

% \chapter{Preliminares}
% \label{chap:preliminaries}

% \chapter{Gramáticas de concatenación de rango}
% \label{chap:RCG}

% \chapter{Lenguaje de las fórmulas booleanas satisfacibles empleando transducción finita}
% \label{chap:LSATFT}

% \chapter{Lenguaje de las fórmulas booleanas satisfacibles empleando gramáticas de concatenación de rango}
% \label{chap:LSATRCG}


Las gramáticas de concatenación de rango (\textit{RCG}) \cite{mainRCGBib} son un formalismo de gramáticas desarrollado en 1988 como una 
propuesta de Pierre Boullier, un investigador en el campo de la lingüística computacional. Su objetivo principal 
era proporcionar un modelo más general y expresivo que las gramáticas libres del contexto para describir lenguajes. 
Las RCG fueron diseñadas con el fin de analizar propiedades y características del lenguaje natural.

Las gramáticas de concatenación de rango se emplean en el capítulo \ref{chap:LSATRCG} para construir una 
gramática que reconozca las fórmulas booleanas satisfacibles.

En la próxima sección se presentan algunas nociones que sirven de introducción para las principales definiciones y conceptos
de las gramáticas de concatenación de rango.

\section{Presentación de los elementos de las gramáticas de concatenación de rango}

En esta sección se presentan nociones sobre la sustitución de rango y las derivaciones de las RCG, aspectos 
que sirven de base para los conceptos y definiciones relacionados con las gramáticas de concatenación de rango.

A los no terminales de esta gramática se les llama predicados y cada predicado tiene un conjunto de argumentos. 
A la cantidad de argumentos de un predicado se le denomina aridad.

Por ejemplo, $A(X,Y)$ representa el no terminal (predicado) $A$, que tiene como argumentos $X$ e $Y$. En este caso, la aridad de $A$ es 2.

Cada argumento de los predicados puede estar formado por variables y terminales. En el caso anterior, $X$ e $Y$ son variables.

Por convenio las variables se denotan por letras mayúsculas del final del alfabeto, y a los terminales, como es 
usual, con letras minúsculas. Con este convenio, el siguiente predicado: $B(aX, XY, abZ)$, tiene aridad 3. Su 
primer argumento está formado por el terminal a y la variable $X$. El segundo argumento por la concatenación 
de las variables $X$ e $Y$. El tercer argumento está formado por la concatenación de los terminales $a$, $b$ y 
la variable $Z$. 

Cada predicado reconoce un vector de cadenas que tiene como dimensión la aridad del predicado y cada cadena 
del vector se asocia a un argumento del predicado.

Por ejemplo, si al predicado $A$ se le asocia el vector $[abc,d]$, al primer argumento de $A$ se le asigna
la cadena $abc$ y al segundo la cadena $d$. Por otro lado, si al predicado $B$ se le asigna el vector $[aa,we,abcc]$,
al primer argumento de $B$ se le asigna la cadena $aa$, al segundo $we$ y al tercero $abcc$.

A las producciones de esta gramática se les denomina cláusulas. La parte izquierda de la producción 
siempre está formada por un único no terminal y en en la parte derecha, pueden existir no terminales 
con sus respectivos argumentos, o la cadena vacía. Un ejemplo de cláusula puede ser la siguiente:
$$A(XYZ,W)\to B(X)C(XY,Z)D(W).$$

La regla anterior tiene el siguiente significado: el no terminal $A$ recibe un vector de dimensión 2. A partir 
de las cadenas del vector, se le asigna valores a las variables $X$, $Y$, $Z$ y $W$, y con esos valores 
construye los vectores que recibirán los no terminales $B$, $C$ y $D$.


El primer argumento de $A$, es $XYZ$, lo cual significa todas las formas de dividir la primera cadena del vector que recibe $A$ en 3 subcadenas de la cadena que no se solapen
y que su concatenación forme la cadena original. El segundo argumento de $A$, es $W$, por tanto se le asigna a $W$ la cadena completa. 
Por ejemplo, si el no terminal $A$ recibe el vector $[abc,d]$ los valores de $X$, $Y$, $Z$ y $W$
pueden ser interpretados de la siguiente manera (Figura \ref{fig:xyz_eaxmple}).


\begin{figure}
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        X             & Y             & Z             & W \\
        \hline
        a             & b             & c             & d \\
        \hline
        ab            & $\varepsilon$ & c             & d \\
        \hline
        ab            & c             & $\varepsilon$ & d \\
        \hline
        abc           & $\varepsilon$ & $\varepsilon$ & d \\
        \hline
        $\varepsilon$ & ab            & c             & d \\
        \hline
        $\varepsilon$ & abc           & $\varepsilon$ & d \\
        \hline
        $\varepsilon$ & $\varepsilon$ & abc           & d \\
        \hline
        a             & $\varepsilon$ & bc            & d \\
        \hline
        $\vdots$      & \vdots        & \vdots        & d \\
        \hline
        a             & bc            & $\varepsilon$ & d \\
        \hline
    \end{tabular}
    \caption{Posibles valores de las variables $X$, $Y$ y $Z$}
    \label{fig:xyz_eaxmple}
\end{figure}

Suponga que la interpretación fue la segunda, en la que $X=ab$, $Y = \varepsilon$, $Z = c$, $W=d$, y con esa asignación de variables se evalúa en los no terminales de su parte derecha: $B(X)C(Y,Z)D(W)$, que en este caso sería $B(ab)C(\varepsilon,c)D(d)$.  Este proceso se repite en cada uno de los predicados del lado derecho de la cláusula.

Existe otro tipo de producciones que son de la forma $A(X_1,\ldots, X_n)\to \varepsilon$. Por ejemplo, las siguientes cláusulas de la gramática anterior son:
$$B(ab)\to \varepsilon,$$
$$C(\varepsilon,c)\to \varepsilon,$$
$$D(d)\to \varepsilon.$$
Si se continúa el proceso de derivación, $B(ab)$, $C(\varepsilon,c)$ y $D(d)$ derivan en la cadena vacía, cuando esto pasa se dice que $B$, $C$ y $D$ reconocen los vectores de cadenas $[ab]$, $[\varepsilon,c]$ y $[d]$ respectivamente. A su vez, $A$ reconoce el vector $[abc,d]$ ya que existe una derivación desde $A(abc,d)$ a $B(ab)C(\varepsilon,c)D(d)$ y cada uno de estos predicados deriva en la cadena vacía.

Con la idea anterior se puede hablar del concepto de rango, que no es más que un par de índices $i$ y $j$, tales que $i\leq j$, estos
representan la subcadena de la cadena de entrada que comienza en el $i$-ésimo caracter y termina en el $j$-ésimo caracter.

El concepto de rango se utiliza cuando se le asigna una cadena a un argumento de un predicado, lo que significa que a cada variable se le asigna un rango de la cadena, tales que estos no se solapen, como se mostró en el ejemplo anterior.

Dadas estas nociones, a continuación se presentan las principales definiciones de las gramáticas de concatenación de rango.

\section{Definiciones}

En esta sección se define el concepto de rango, gramática de concatenación de rango, sustitución de rango y gramática de concatenación de rango positiva.

\begin{definition}
    Un \textbf{rango} es una tupla $(i, j)$ que representa un intervalo de posiciones en una cadena, donde $i$ y $j$ son enteros no negativos tales que $i \leq j$.    
\end{definition}

Por ejemplo, para la cadena $abcd$, el rango $(1,2)$, representa la subcadena $bc$.

\begin{definition}
    Una \textbf{gramática de concatenación de rango} \footnote{En la literatura este tipo de RCG se toma com gramática de concatenación de rango positiva, pero como es la única que
        se usa en este trabajo se le llama solo gramática de concatenación de rango} se define como una 5-tupla
    :
    \[
        G = (N, T, V, P, S),
    \]
    donde:
    
    \begin{itemize}
        \item $N$: Es un conjunto finito de \textbf{predicados o símbolos no terminales}: Cada predicado tiene una \textbf{aridad}, que indica la dimensión del vector de cadenas que reconoce y cada cadena del vector se asocia a un argumento del predicado.
        \item $T$: Es un conjunto finito de \textbf{símbolos terminales}.
        \item $V$: Es un conjunto finito de \textbf{variables}.
        \item $P$: Es un conjunto finito de \textbf{cláusulas}, de la forma:
              \[
                  A(x_1, x_2, \ldots, x_k) \to B_1(y_{1,1}, y_{1,2}, \ldots, y_{1,m_1}) \ldots B_n(y_{n,1}, y_{n,2}, \ldots, y_{n,m_n}),
              \]
              donde $A, B_i \in N$, $x_i, y_{i,j} \in (V \cup T)^*$, y $k$ es la aridad de $A$.
        \item $S \in N$: Es el \textbf{predicado inicial} de la gramática, que siempre tiene \textbf{aridad} 1.
    \end{itemize}
\end{definition}


Por ejemplo, a continuación se muestra una gramática de concatenación de rango:
\label{g_3copy}
\[
    G^3_{copy} = (N, T, V, P, S),
\]
donde:

\begin{itemize}
    \item  N=$\{A,S\}$.
    \item T=$\{a,b,c\}$.
    \item V=$\{X,Y,Z\}$.
    \item El conjunto de cláusulas $P$ es el siguiente:
          \begin{enumerate}
              \item $S(XYZ)\to A(X,Y,Z)$
              \item $A(aX,aY,aZ)\to A(X,Y,Z)$
              \item $A(bX,bY,bZ)\to A(X,Y,Z)$
              \item $A(cX,cY,cZ)\to A(X,Y,Z)$
              \item $A(\varepsilon,\varepsilon,\varepsilon)\to \varepsilon$
          \end{enumerate}
    \item El símbolo inicial es $S$.
\end{itemize}

\begin{definition}
    Una \textbf{sustitución de rango} es un mecanismo que reemplaza una variable por un 
    rango de la cadena, respetando la estructura del argumento que se asocia a la cadena que se reconoce. 
\end{definition}

Por ejemplo, dado el predicado $A(Xa)$ donde $X \in V$ y $a \in T$, la estructura el argumento de $A$ es una 
variable $X$ seguida del terminal $a$. Si el no terminal $A$ recibe la cadena $baa$, $X$ se puede asociar 
con el rango $ba$ de la cadena original porque si $X=ba$, entonces  $Xa=baa$ y esa es justamente la cadena 
que recibió $A$.

Por otro lado, la variable $X$ no puede tomar el valor $baa$, porque ningún caracter de la cadena de entrada coincidiría con el terminal $a$. De manera similar, $X$ tampoco puede tomar el valor $b$ porque el valor que se asigna a $X$ no cubre la cadena completa.

\begin{definition}
    Las \textbf{gramáticas de concatenación de rango simple}
    (\textit{SRCG}) son un subconjunto de las RCG que restringen la forma de las cláusulas de producción.  
    Una RCG $G$ es \textbf{simple} si los argumentos en el lado derecho de una cláusula son variables distintas, 
    y todas estas variables (y no otras) aparecen una sola vez en los argumentos del lado izquierdo.  
\end{definition}

Este es un caso particular de las RCG el cual se usa en \cite{aSRCSAT} para describir el orden de las variables de una fórmula booleana.

En la próxima sección se describe el proceso de derivación de las RCG.

\section{Proceso de derivación}

La idea principal para realizar una derivación en la cláusula 
\[
    A(x_1, x_2, \ldots, x_k) \to B_1(y_{1,1}, y_{1,2}, \ldots, y_{1,m_1}) \ldots B_n(y_{n,1}, y_{n,2}, \ldots, y_{n,m_n}),
\]
de una RCG, se basa en tomar el vector de cadenas $[w_1, w_2,\ldots, w_k]$ que recibe el predicado $A$ y asociar cada cadena al argumento 
correspondiente, $w_1$ se asocia al argumento $x_1$, $w_2$ se asocia al argumento $x_2$ y así hasta que por último
$w_k$ se asocia a $x_k$. 

Después se realizan todas las posibles sustituciones en rango para cada argumento y se asocia un rango a 
cada variable del predicado izquierdo.

Los valores de las variables obtenidos en el paso anterior se instancian en las variables de los predicados del lado derecho de la cláusula.

Por ejemplo, se tiene la cláusula $A(X,aYb)\to B(aXb,Y)$ , donde $X$ e $Y$ son variables y $a$ y $b$ son símbolos 
terminales. Cuando $A$ recibe el vector $[a,abb]$, $a$ coincide con $X$ y $abb$ coincide con $aYb$. La única sustitución de 
rango posible es cuando $X=a$ y $Y=b$, por tanto el predicado $A(a,abb)$ deriva como $B(aab,b)$.

Las RCG, a diferencia de las gramáticas definidas en la sección \ref{sec:grammars} del capítulo \ref{chap:preliminaries} no generan cadenas, su funcionamiento se basa en reconocer si una cadena pertenece o no al lenguaje.

Un vector de cadenas se reconoce por un predicado $A$ si existe una secuencia de derivaciones que comienza en $A$ y termina en la cadena vacía.

Por ejemplo, dada la cláusula $A(X_1,X_2,X_3)\to B_1(X_1)B_2(X_2)B_3(X_3)$, el vector $[w_1,w_2,w_3]$ se reconoce por $A$, si existe una secuencia de derivaciones para cada uno de los predicados $B_1(w_1)$, $B_2(w_2)$, $B_3(w_3)$ que derive en la cadena vacía.

A continuación se presenta un ejemplo de reconocimiento de la cadena $abcabcabc$ por la gramática $G^3_{copy}$
presentada en la página \pageref{g_3copy}.

La cadena $abcabcabc$ se reconoce por $G^3_{copy}$, ya que $S(abcabcabc)$ se puede derivar de la siguiente manera:
$$S(abcabcabc)\to A(abc,abc,abc)\to A(bc,bc,bc)\to A(c,c,c)\to A(\varepsilon,\varepsilon,\varepsilon)\to \varepsilon.$$

El proceso de reconocimiento de la cadena $abcabcabc$ por la gramática $G^3_{copy}$ se detalla como sigue.

\begin{itemize}
    \item \textbf{Primer paso:} En la primera cláusula $S(XYZ)\to A(X,Y,Z)$, la sustitución de rango asocia las
          variables $X$, $Y$, $Z$ a los valores $X=abc$, $Y=abc$ y $Z=abc$ y se deriva en el predicado $A(abc,abc,abc)$.
    \item \textbf{Segundo paso:} En la segunda cláusula $A(aX,aY,aZ)\to A(X,Y,Z)$, la sustitución de rango asocia las
          variables $X$, $Y$, $Z$ a los valores $X=bc$, $Y=bc$ y $Z=bc$ y se deriva en el predicado $A(bc,bc,bc)$.
    \item \textbf{Tercer paso:} En la tercera cláusula $A(bX,bY,bZ)\to A(X,Y,Z)$, la sustitución de rango asocia las
          variables $X$, $Y$, $Z$ a los valores $X=c$, $Y=c$ y $Z=c$ y se deriva en el predicado $A(c,c,c)$.
    \item \textbf{Cuarto paso:} En la cuarta cláusula $A(cX,cY,cZ)\to A(\varepsilon,\varepsilon,\varepsilon)$, la sustitución de rango asocia las
          variables $X$, $Y$, $Z$ a los valores $X=\varepsilon$, $Y=\varepsilon$ y $Z=\varepsilon$ y se deriva en el predicado $A(\varepsilon,\varepsilon,\varepsilon)$.
    \item \textbf{Quinto paso:} Finalmente en el último paso se toma la última
          cláusula $A(\varepsilon,\varepsilon,\varepsilon)\to \varepsilon$ que deriva en la cadena vacía, por lo que de esta manera se reconoce la cadena $abcabcabc$.
\end{itemize}

Se puede demostrar que la gramática $G^3_{copy}$, reconoce el lenguaje $L_{copy}^3=\{www\mid w\in \{a,b,c\}^*\}$.

A continuación se presentan las propiedades de las RCG que demuestran
que las RCG no son cerradas bajo transducción finita, esto no permite construir el lenguaje de todas las fórmulas
satisfacibles mediante una transducción finita usando una RCG, lo anterior se analiza en el capítulo \ref{chap:LSATRCG}.

\section{Propiedades de las RCG}

En esta sección se describen las principales propiedades de las RCG que demuestran que las RCG no son cerradas 
bajo transducción finita. Además en esta sección se presenta el problema de la palabra 
para las RCG, el cual se emplea en el capítulo \ref{chap:LSATRCG} para determinar si una fórmula booleana es satisfacible.

\begin{itemize}
    \item  \textbf{No cerradas bajo homomorfismo:} Dada una RCG $G$, el homomorfismo de un lenguaje que se reconoce por $G$ necesariamente no se reconoce por una RCG \cite{propertiesRCGBib}.
    \item \textbf{No cerradas bajo transducción finita:} Dada una RCG $G$, la transducción finita de un lenguaje que se reconoce por $G$ necesariamente no se reconoce por una RCG. Esto es una consecuencia de la propiedad anterior porque un homomorfismo es un transductor finito de un solo estado y tantas transiciones hacia el mismo estado como transformaciones de símbolos en el homomorfismo.
\end{itemize}

En este trabajo se propone una forma para construir el lenguaje de todos los SAT satisfacibles, y esto depende de un formalismo que 
sea capaz de describir una variante de $L_{copy}$ y sea cerrado bajo transducción finita. Sin embargo, esta forma de construir el lenguaje es solo suficiente 
y no necesaria porque existen formalismos que no son cerrados bajo transducción finita (como las RCG) que también 
describen el lenguaje.

En \cite{mainRCGBib} se menciona que en la mayoría de los casos el problema de la palabra para las RCG es polinomial y se resuelve mediante un algoritmo de memorización sobre las cadenas asignadas a los argumentos de los predicados de la RCG \cite{mainRCGBib}.  Como la cantidad máxima de rangos de la cadena es $n^2$ y la máxima aridad de un predicado es constante, este proceso de memorización cuenta con una cantidad polinomial de estados, y tiene una complejidad de $O(|P|n^{2h(l+1)})$ donde $h$ es la máxima aridad en un predicado, $l$ es la máxima cantidad de predicados en el lado derecho de una cláusula y $n$ es la longitud de la cadena que se reconoce.

Sin embargo, existen casos en los que el problema de la palabra no es polinomial, en la siguiente sección se analiza un caso en el que este problema no es polinomial.

\subsection{Problema de la palabra no polinomial para las RCG}

El algoritmo de reconocimiento que se menciona en la sección anterior utiliza un proceso de memorización sobre 
los rangos de la cadena.  La idea fundamental para esto y lo que acota la complejidad del algoritmo es que la 
cantidad de estados asociados a la memorización es igual a la cantidad de rangos de la cadena, el cual es 
polinomial con respecto a la longitud de la cadena. Esto se cumple siempre que todos los argumentos que reciben 
todos los no terminales de la gramática sean subcadenas de la cadena original que se está analizando. Existen 
gramáticas de concatenación de rango en que esto no ocurre, como en la que se muestra a continuación.

La siguiente RCG reconoce el lenguaje $L=\{w\,|\,w\in\{0,1\}^*\}$, esta no tiene uso real porque existe otra RCG equivalente que reconoce el
mismo lenguaje, pero ilustra una RCG donde se generan cadenas que no son subcadenas de la cadena de entrada durante el proceso
de reconocimiento:
\[
    G = (N, T, V, P, S),
\]
donde:

\begin{itemize}
    \item  N=$\{A,B,Eq,S\}$.
    \item T=$\{0,1\}$.
    \item V=$\{X,Y\}$.
    \item El conjunto de cláusulas $P$ es el siguiente:
          \begin{enumerate}
              \item $S(X)\to A(X,X)$
              \item $A(1X,Y)\to B(X,0,Y)$
              \item $A(1X,Y)\to B(X,1,Y)$
              \item $A(0X,Y)\to B(X,1,Y)$
              \item $A(0X,Y)\to B(X,0,Y)$
              \item $B(1X,Y,Z)\to B(X,1Y,Z)$
              \item $B(1X,Y,Z)\to B(X,0Y,Z)$
              \item $B(0X,Y,Z)\to B(X,0Y,Z)$
              \item $B(0X,Y,Z)\to B(X,1Y,Z)$
              \item $B(\varepsilon,Y,Z)\to Eq(Y,Z)$
          \end{enumerate}
          
    \item El símbolo inicial es $S$.
\end{itemize}

Para procesar una cadena $w$, la gramática anterior genera todas las posibles cadenas $q$, tales que $|w|=|q|$ y luego comprueba si $w = q$.

Esta gramática no tiene caso de uso ya que para toda cadena $w$ siempre va a existir una cadena $q$ tal que $w=q$, 
por lo que se puede modelar con solamente la cláusula $S(X)\to \varepsilon$. Pero la complejidad del 
reconocimiento de $G$ es mayor que $2^n$ (con $n$ igual al tamaño de la cadena de entrada), ya que esta es la 
cantidad de cadenas posibles que puede recibir el segundo argumento del predicado $B$, porque la gramática es 
ambigua y en cada derivación de $B$ existen 2 posibles decisiones, se añade un 1 delante al valor de la $Y$ o 
se añade un $0$. Las siguientes cláusulas ilustran lo planteado anteriormente:

$$B(1X,Y,Z)\to B(X,1Y,Z),$$
$$B(1X,Y,Z)\to B(X,0Y,Z),$$
$$B(0X,Y,Z)\to B(X,0Y,Z),$$
$$B(0X,Y,Z)\to B(X,1Y,Z).$$

En el capítulo \ref{chap:LSATRCG} se presenta una RCG que reconoce fórmulas booleanas satisfacibles,
pero es ambigua, con el problema de la palabra no polinomial.

En este capítulo se analizaron las principales definiciones y propiedades de las RCG, que son utilizadas en el capítulo \ref{LSATRCG} para definir una gramática que reconozca las fórmulas booleanas satisfacibles.  En el próximo capítulo se presenta un primer enfoque para definir el lenguaje de todas las fórmulas booleanas satisfacibles y a esta idea se le da continuidad en el capítulo \ref{chap:LSATRCG}, mediante las RCG.

\begin{thebibliography}{99}
    
    \bibitem{mainRCGBib}
    Boullier, Pierre.
    \textit{Proposal for a Natural Language Processing Syntactic Backbone}.
    Research Report RR-3342, INRIA, 1998.
    
    \bibitem{propertiesRCGBib}
    Boullier, Pierre.
    \textit{A Cubic Time Extension of Context-Free Grammars}.
    Research Report RR-3611, INRIA, 1999.
    
    \bibitem{simpleMatrixLanguages}
    Ibarra, Oscar H.
    \textit{Simple matrix languages}.
    \textit{Information and Control}, Vol. 17, No. 4, pp. 359-394, 1970.
    
    \bibitem{globalIndexLanguages}
    Castaño, José M.
    \textit{Global Index Languages}.
    Ph.D. Thesis, The Faculty of the Graduate School of Arts and Sciences, Brandeis University, 2004.
    
    \bibitem{authomataTheory}
    Hopcroft, John E., Motwani, Rajeev, y Ullman, Jeffrey D.
    \textit{Introduction to Automata Theory, Languages, and Computation}.
    3ª edición, Addison-Wesley, 2006. ISBN: 9780321455369.
    
    \bibitem{aCFSAT}
    Fernández Arias, Alina.
    \textit{El problema de la satisfacibilidad booleana libre del contexto}.
    Facultad de Matemática y Computación, Universidad de La Habana, 2007.
    
    \bibitem{aSRCSAT}
    Aguilera López, Manuel.
    \textit{Problema de la Satisfacibilidad Booleana de Concatenación de Rango Simple}.
    Facultad de Matemática y Computación, Universidad de La Habana, 2016.
    
    \bibitem{aSMSAT}
    Rodríguez Salgado, José Jorge.
    \textit{Gramáticas Matriciales Simples. Primera aproximación para una solución al problema SAT}.
    Facultad de Matemática y Computación, Universidad de La Habana, 2019.
    
\end{thebibliography}


\end{document}