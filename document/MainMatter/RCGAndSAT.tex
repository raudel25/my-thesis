\chapter{Estrategia para la solución del SAT usando gramáticas de concatenación de rango}
\label{chap:LSATRCG}

En este capítulo se aborda la estrategia presentada en el capítulo anterior (resolver el SAT usando el problema
de la palabra) utilizando gramáticas de concatenación de rango. Además se obtiene un resultado que permite
demostrar que las RCG reconocen todos los problemas que pertenecen a la clase NP y se deja como problema
abierto obtener una RCG que permita reconocer todas las instancias de SAT que son solubles en tiempo polinomial.

Para ello primeramente se describe como reconocer el lenguaje $L_{0,1}$ mediante una gramática de concatenación
de rango y a continuación se describe porque no es posible usar las RCG para construir el lenguaje $L_{S-SAT}$
mediante una transducción finita usando RCG. Luego se presenta una RCG que reconoce todas las fórmulas booleanas
satisfacibles y se demuestra que las RCG reconocen todos los problemas en la clase NP. Por último se presenta una
RCG que permite reconocer problemas 2-SAT, pero que tiene el problema de la palabra no polinomial.

En la siguiente sección se describe una RCG que reconoce el lenguaje $L_{0,1}$.

\section{$L_{0,1}$ como lenguaje de concatenación de rango}

En esta sección se presenta una RCG que reconoce el lenguaje $L_{0,1}=\{wd\}^+$ donde $w\in \{0,1\}^*$, el cual sirve para la asignación
de valores a las variables de un SAT. La gramática que se emplea se basa en reconocer primeramente
una cadena $w$, luego un caracter $d$ y después comprobar que las siguientes cadenas sean iguales a $w$
seguidas del caracter $d$.

Para reconocer $L_{0,1}$ se define la gramática $G_{0,1}$ como sigue:
\[
    G_{0,1} = (N, T, V, P, S),
\]
donde:

\begin{itemize}
    \item $N=\{S,A,B,C,Eq\}$
    \item $T=\{0,1,d\}$.
    \item $V=\{X,Y,P\}$.
    \item El conjunto de cláusulas $P$ es el siguiente:
          \begin{enumerate}
              \item $S(X)\to A(X)$
              \item $A(XdY)\to B(Y,X)C(X)$
              \item $B(XdY,P)\to B(Y,P) C(X) Eq(X,P)$
              \item $B(\varepsilon,P)\to \varepsilon$
              \item $C(0X)\to C(X)$
              \item $C(1X)\to C(X)$
              \item $C(\varepsilon)\to \varepsilon$
          \end{enumerate}
    \item El \textbf{símbolo inicial} es $S$.
\end{itemize}

El predicado $Eq$ se define en \cite{mainRCGBib} y comprueba que dos cadenas sobre un alfabeto sean iguales.
Por otro lado el predicado $B$ recibe un patrón y una cadena y mediante la sustitución en rango determina
si algún prefijo de la cadena que este seguido de una $d$ es igual al patrón. Luego continúa la derivación
del resto de la cadena en el predicado $B$ con el mismo patrón. Finalmente si la cadena que recibe $B$ es la cadena
vacía entonces se deriva en la cadena vacía. Esto permite que $G_{0,1}$ reconozca el lenguaje $L_{0,1}$.

A continuación se presenta un ejemplo de cómo $G_{0,1}$ reconoce la cadena $101d101d101d$.

\subsection{Ejemplo de reconocimiento de una cadena por $G_{0,1}$}

En esta sección se describen las derivaciones que permiten reconocer la cadena $101d101d101d$. Las derivaciones
de la gramática son las siguientes:

\paragraph{Definición:} para mostrar un paso de la derivación primero se muestra el predicado izquierdo de la cláusula
seleccionada, instanciado con los valores de los rangos correspondientes y los predicados en los que deriva, luego se específica la cláusulas seleccionada
(ejemplo c-4, significa que se selecciona la cuarta cláusula) y después se muestran los valores que toma cada variable
en la sustitución en rango.

\begin{enumerate}
    \item $S(101d101d101d) \to A(101d101d101d)$: c-1, $X=101d101d101d$
    \item $A(101d101d101d) \to B(101d101d,101)C(101)$: c-2, $X=101$ $Y=101d101d$
    \item $B(101d101d,101) \to B(101d,101)C(101)Eq(101,101)$: c-3, $X=101$ $Y=101d$ $P=101$
    \item $B(101d,101) \to B(\varepsilon,101)C(101)Eq(101,101)$: c-3, $X=101$ $Y=\varepsilon$ $P=101$
    \item $B(\varepsilon,101) \to \varepsilon$: c-4, $P=101$
    \item $C(101)\to C(01)$: c-6, $X=01$
    \item $C(01)\to C(1)$: c-5, $X=1$
    \item $C(1)\to C(\varepsilon)$: c-6 $X=\varepsilon$
    \item $C(\varepsilon)\to \varepsilon$: c-7
\end{enumerate}

Como todos los predicados derivan en la cadena vacía entonces $101d101d101d$ es reconocida por $G_{0,1}$.

A continuación se analiza porque no es posible construir $L_{S-SAT}$ mediante una transducción finita usando
una RCG

\subsection{Construir $L_{S-SAT}$ mediante una transducción finita usando una RCG}

Como se mostró en la sección anterior el lenguaje $L_{0,1}$ se reconoce mediante una RCG.  Entonces,
siguiendo con la idea abordada en las secciones del capítulo \ref{chap:LSATFT}, que busca construir
$L_{S-SAT}$ mediante una transducción finita, se puede usar $G_{0,1}$ como formalismo para generar
$L_{0,1}$. Esto no es posible porque  las RCG no son cerradas bajo transducción finita como se mencionó en
el capítulo \ref{chap:RCG}.  Por ello no se puede asegurar que al aplicarle el transductor $T_{SAT}$
a la RCG que reconoce el lenguaje $L_{0,1}$ se obtenga una RCG, por lo cual no se puede realizar el
análisis del problema de la palabra como se propuso en el capítulo \ref{chap:LSATFT}.

Se pudiera analizar qué tipo de formalismo se obtiene al aplicar
el transductor $T_{SAT}$ sobre la RCG que reconoce $L_{0,1}$ y realizar un análisis de la complejidad del
problema de la palabra para dicho formalismo.

Otro aspecto a considerar sería investigar qué propiedades de las RCG limitan que estas no sean cerradas
bajo transducción finita y dado esas propiedades identificadas comprobar si todavía es posible reconocer
el lenguaje $L_{0,1}$.

A continuación se presenta un enfoque distinto para construir $L_{S-SAT}$ que no emplea la transducción
finita, la cual se basa en una RCG que reconozca los problemas SAT satisfacibles.

\section{Reconocer $L_{S-SAT}$ mediante una RCG}

En esta sección se presenta una RCG que es capaz de reconocer las fórmulas booleanas satisfacibles. Esto permite demostrar que las
RCG reconocen todos los problemas de la clase NP y da respuesta a la pregunta formulada en el capítulo \ref{chap:LSATFT}: si es necesario
el transductor $T_{SAT}$ para construir $L_{S-SAT}$ mediante un formalismo de escritura regulada.

En la definición de $L_{S-SAT}$ mediante una transducción finita se genera mediante el lenguaje $L_{0,1}$
todas las posibles interpretaciones de cualquier fórmula booleana y luego el transductor $T_{S-SAT}$ genera
todas las posibles fórmulas booleanas satisfacibles según las interpretaciones generadas por $L_{0,1}$.
En esta sección en cambio se presenta un RCG que reconoce las fórmulas booleanas satisfacibles, la cual se
basa en generar mediante el reconocimiento de la cadena de entrada todas las posibles
interpretaciones de la fórmula booleana que satisfacen la primera cláusula y luego comprobar si dicha
interpretación satisface el resto de las cláusulas.


Para reconocer $L_{S-SAT}$ define la siguiente RCG:
\[
    G_{S-SAT} = (N, T, V, P, S),
\]
donde:

\begin{itemize}
    \item $N=\{S,A,B,C,P,N,Cp,Cn\}$
    \item $T=\{a,b,c,d\}$.
    \item $V=\{X,Y,X_1,X_2\}$.
    \item El \textbf{símbolo inicial} es $S$.
\end{itemize}

A continuación se desglosa el conjunto de \textbf{cláusulas} $P$ en 4 fases agrupando las cláusulas por funcionalidad.
La primera representa la derivación inicial de la gramática. La segunda se encarga de generar todas las posibles interpretaciones
de las variables que satisfacen la primera cláusula. En esta fase se definen 2 estados, positivo (significa
que la cadena de 0 y 1 generada ya satisface la primera cláusulas) y negativo (significa que la cadena de 0 y 1
generada aún no satisface la primera cláusulas), representados por los predicados $P$ y $N$ respectivamente.
La tercera comprueba que la interpretación definida en la fase anterior sea satisfacible para el resto de las
cláusulas. Por último la cuarta fase define el algoritmo para determinar si una interpretación satisface una
cláusula dada. En esta fase se definen 2 estados, positivo (significa que la interpretación ya satisface la cláusulas actual)
y negativo (significa que la interpretación aún no satisface la cláusula actual), representados por los predicados $P$ y $N$ respectivamente  Finalmente, si para una cadena que representa una fórmula booleana existe una secuencia de
derivaciones desde el predicado inicial pasando por cada fase hasta la cadena vacía entonces la cadena se
reconoce.

\begin{itemize}
    \item \textbf{Primera fase:} Representa la cláusula de derivación inicial de la gramática:
          \begin{enumerate}
              \item $S(X)\to A(X)$.
          \end{enumerate}

    \item \textbf{Segunda fase:} El siguiente conjunto de cláusulas genera la cadena de 0 y 1 que que da
          valores a las variables de la fórmula booleana, los cuales satisfacen la primera cláusula.
          \begin{multicols}{2}
              \begin{enumerate}[start=2]
                  \item $A(aX)\to P(X,1)$
                  \item $A(aX)\to N(X,0)$
                  \item $A(bX)\to N(X,1)$
                  \item $A(bX)\to P(X,0)$
                  \item $A(cX)\to N(X,1)$
                  \item $A(cX)\to N(X,0)$

                  \item $P(aX,Y)\to P(X,Y1)$
                  \item $P(aX,Y)\to P(X,Y0)$
                  \item $P(bX,Y)\to P(X,Y1)$
                  \item $P(bX,Y)\to P(X,Y0)$
                  \item $P(cX,Y)\to P(X,Y1)$
                  \item $P(cX,Y)\to P(X,Y0)$
                  \item $P(dX,Y)\to B(X,Y)$

                  \item $N(aX,Y)\to P(X,Y1)$
                  \item $N(aX,Y)\to N(X,Y0)$
                  \item $N(bX,Y)\to N(X,Y1)$
                  \item $N(bX,Y)\to P(X,Y0)$
                  \item $N(cX,Y)\to N(X,Y1)$
                  \item $N(cX,Y)\to N(X,Y0)$
              \end{enumerate}
          \end{multicols}

          $A$ representa el predicado por donde inician las derivaciones de esta fase. De este se deriva a los
          predicados $P$ (representa que la cláusula ya tiene un valor de verdad positivo) y $N$
          (representa que la cláusula de la fórmula booleana se encuentra aún con un valor de verdad negativo)
          en dependencia del valor asignado. El predicado $P$ deriva hacia sí mismo independientemente del
          símbolo, exceptuando el símbolo $d$, caso en el que se deriva en $B$ y se procede a la siguiente fase.

    \item \textbf{Tercera fase:} El siguiente conjunto de cláusulas comprueba que la asignación de variables que se realiza en la fase anterior se verdadera
          para las restantes cláusulas.
          \begin{enumerate}[start=21]
              \item $B(X_1dX_2,Y)\to C(X_1,Y) B(X_2,Y)$
              \item $B(\varepsilon,Y)\to\varepsilon$
          \end{enumerate}

          El predicado $B$ permite realizar la iteración sobre las cláusulas restantes mientras que el predicado $C$ comprueba que la cláusula de la fórmula booleana actual sea satisfacible, comportamiento que se encuentra definido en la cuarta fase.

    \item \textbf{Cuarta fase:} En esta fase se define el comportamiento de $C$, que recibe una cláusula y una
          interpretación de las variables y comprueba que dicha interpretación sea verdadera para la cláusula analizada.
          \begin{enumerate}[start=23]
              \begin{multicols}{2}
                  \item $C(X,Y)\to Cn(X,Y)$

                  \item $Cn(aX,1Y) \to Cp(X,Y)$
                  \item $Cn(aX,0Y) \to Cn(X,Y)$
                  \item $Cn(bX,1Y) \to Cn(X,Y)$
                  \item $Cn(bX,0Y) \to Cp(X,Y)$
                  \item $Cn(cX,1Y) \to Cn(X,Y)$
                  \item $Cn(cX,0Y) \to Cn(X,Y)$

                  \item $Cp(aX,1Y) \to Cp(X,Y)$
                  \item $Cp(aX,0Y) \to Cp(X,Y)$
                  \item $Cp(bX,1Y) \to Cp(X,Y)$
                  \item $Cp(bX,0Y) \to Cp(X,Y)$
                  \item $Cp(cX,1Y) \to Cp(X,Y)$
                  \item $Cp(cX,0Y) \to Cp(X,Y)$
                  \item $Cp(\varepsilon,\varepsilon)\to \varepsilon$
              \end{multicols}
          \end{enumerate}

          Observe que este funcionamiento es exactamente igual al de la primera fase con un predicado que representa un
          estado positivo ($Cp$) y un predicado que representa un estado positivo ($Cn$). Pero esta vez no se genera
          la cadena sino que se comprueba con un patrón, el cual se predefine en la segunda fase y pasa a las
          siguientes mediante las derivaciones de la gramática.

\end{itemize}

A continuación se demuestra que el lenguaje reconocido por $G_{S-SAT}$ es exactamente igual al lenguaje que representa todas las fórmulas booleanas satisfacibles descritas mediante
la transformación definida en el lenguaje $L_{FULL-SAT}$.

\subsubsection{Demostración de la gramática $G_{S-SAT}$}

La idea para la demostración de que el lenguaje reconocido por $G_{S-SAT}$ es exactamente igual al lenguaje
que representa todas las fórmulas booleanas satisfacibles se basa en demostrar el correcto funcionamiento de las 4
fases de la gramática y luego demostrar que una representación de una fórmula booleana es reconocida por $G_{S-SAT}$
si  y solo si dicha fórmula es satisfacible.

Primeramente, se demuestra que el predicado $C$ que pertenece a la cuarta fase reconoce los argumentos $X$ y $Y$
si y solo si $Y$ satisface la cláusula de la fórmula booleana asociada a $X$. Posteriormente, se prueba que el predicado $B$,
asociado a la tercera fase, reconoce los argumentos $X$ y $Y$ si y solo si $Y$ satisface todas las cláusulas
asociadas a $X$, funcionamiento presente en la segunda cláusula.  Luego, se demuestra  que el conjunto de cadenas
$Q$ formado por todas las cadenas $Y$ tales que existe una secuencia de derivaciones desde del predicado
$A(X_1)$ hasta $B(X_2,Y)$ es exactamente igual a al conjunto de todas las interpretaciones que hacen verdadera
la primera cláusula de $X_1$, funcionamiento presente en la primera cláusula. Por último, se prueba
que el conjunto de cadenas $X$ que se reconocen por el predicado inicial $S$ es exactamente igual al
conjunto de la representación de todas las fórmulas booleanas satisfacibles.

A continuación se presenta la demostración para el funcionamiento de cada fase. Primero se demuestra
el funcionamiento de la cuarta fase, luego la tercera, después la segunda y por último la primera.
Ya que la demostración de la tercera depende de la cuarta y la demostración de la primera depende de la
segunda y de la tercera.

\begin{itemize}
    \item \textbf{Cuarta fase:} Sea el predicado $C(w,e)$.

          Para demostrar el funcionamiento de la cuarta fase primeramente suponga que la fórmula booleana
          asociada a $w$, la cual se denomina $F_w$ es satisfacible por $e$, entonces se debe demostrar
          que existe una secuencia de derivaciones desde $C(w,e)$ hasta la cadena vacía.

          Como $e$ satisface a $F_w$ existe una variable sin negar con valor un 1 o un variable negada con valor 0.
          Del predicado $C$ se deriva al predicado $Cn$, la única derivación de la gramática donde se deriva del predicado $Cn$ a $Cp$ es precisamente
          la combinación de una $a$ y un 1 o de una $b$ y un 0 y como $e$ satisface $F_w$ esta combinación existe.
          Por último $Cp$ siempre deriva en sí mismo o en la cadena vacía por lo tanto queda demostrado que existe
          una secuencia de derivaciones desde $C(w,e)$ hasta la cadena vacía.

          La demostración del funcionamiento de la cuarta fase la completa el hecho de que si $C(w,e)$ se reconoce
          entonces $e$ satisface a $w$. Por la estructura de la gramática si existe una secuencia de derivaciones
          desde $C(w,e)$ hasta la cadena vacía entonces hay una derivación desde $Cn$ hacia $Cp$ y esta derivación
          solo es posible por una combinación de una $a$ y un 1 o de una $b$ y un 0, por lo tanto una de estas
          combinaciones existe. Luego existe en $F_w$ una variable sin negar con valor 1 o una variable negada
          con valor 0 lo cual implica que $e$ satisface $F_w$.

    \item \textbf{Tercera fase:} Sea el predicado $B(w,e)$ y la cláusula $B(X_1dX_2,Y)\to C(X_1,Y) B(X_2,Y)$.

          Para demostrar el funcionamiento de la tercera fase se hará una inducción sobre la cantidad de
          cláusulas $n$ de la fórmula booleana asociada a $w$. Para $n=1$ se cumple que, al realizar la sustitución
          en rango, los rangos asociados a las variables $X_1$ y $X_2$ son $w$ sin su último caracter y la cadena
          vacía respectivamente, por tanto $B(w,e)$ se reconoce por la gramática si y solo si $C(X_1,e)$ se reconoce
          y esto solo es posible si $e$ satisface a $X_1$, por lo que se demuestra el caso base.

          Una vez demostrado el caso base corresponde asumir para $n=k$ y se demuestra para $k+1$.

          En todas las posibles sustituciones en rango de $X_1$ y $X_2$, $C(X_1,e)$ solo se reconoce si $|X_1|=|e|$,
          entonces el caso de sustitución en rango que ocupa a la demostración es si $|X_1|=|e|$, es decir si $X_1$ es igual a
          la primera cláusula de $w$. Luego $e$ satisface todas las cláusulas de $w$ si y solo si satisface $X_1$
          (la primera cláusula de w)y $X_2$ (el resto de las cláusulas de $w$) y precisamente $B(w,e)$ se reconoce si y
          solo si se reconoce $C(X_1,e)$ y $B(X_2,e)$. $C(X_1,e)$ se demuestra por el funcionamiento de la cuarta fase
          y $B(X_2,e)$ se demuestra por hipótesis de inducción, ya que $X_2$ tiene $n$ cláusulas.

    \item \textbf{Segunda fase:} Sea el predicado $A(q)$.

          Para la demostración del funcionamiento de la segunda fase se utilizan 2 conjuntos: $W$ representa el
          conjunto de todas las cadenas de 0 y 1, que satisfacen la primera cláusula de la fórmula asociada a
          $q$ ($F_{1q}$) y $E$, representa el conjunto de todas las cadenas $e$ tales que existe una secuencia
          de derivaciones desde $A(q)$ hasta $B(z_q,e)$, donde $z_q$ esta conformada por todas las cláusulas de
          $q$ menos la primera. Dadas estas definiciones es necesario demostrar que $W=E$, para ello se debe
          demostrar que $W$ es subconjunto de $E$ y $E$ es subconjunto de  $W$.

          Para demostrar que $W\subseteq E$, se toma una cadena $w$ tal que $w\in W$, es decir, $w$ satisface
          a $F_{1q}$. Por tanto en $F_{1q}$ existe una variable sin negar con valor 1 en $w$, o existe una
          variable negada con valor 0 en $w$, lo que representa una combinación de una $a$ y un 1 o de una $b$
          y un 0 en una de las derivaciones de la segunda fase.

          Por la estructura de la gramática del predicado $A$, solo hay derivaciones a $P$ con una de estas 2
          combinaciones, el resto son hacia el predicado $N$ y del predicado $N$ solo hay derivaciones a $P$
          con una de las combinaciones anteriores. Por tanto como existe una combinación de una $a$ y un 1 o
          de una $b$ y un 0, existe una secuencia de derivaciones que lleva del predicado $A$ al predicado
          $P$ pasando por $N$ o sin pasar por $N$. Como el predicado $P$ solo tiene derivaciones hacia sí
          mismo o hacia $B(z_q,w)$ se cumple que $w\in E$.

          Para demostrar que $Q\subseteq W$, se toma una cadena $e$ tal que $e\in E$, es decir, existe una
          secuencia de derivaciones desde $A(q)$ a $B(z_q,e)$. Por la estructura de la gramática solo se
          puede derivar al predicado $B$ desde el predicado $P$ y a su vez a este predicado solo se puede
          derivar mediante una combinación de una $a$ y un 1 o de una $b$ y un 0 en la gramática. Por tanto
          $F_{1q}$ tiene una variable sin negar con valor 1 en $e$ o una variable negada con valor 0 en $e$.
          Entonces se cumple que $e$ satisface a $F_{1q}$ por lo que $e\in W$. Con esto se demuestra que $E=W$.

    \item \textbf{Primera fase:} Sea el predicado $S(q)$.

          Para demostrar que el lenguaje que reconoce $G_{S-SAT}$ es exactamente igual al lenguaje que
          representa todas las fórmulas booleanas satisfacibles se define el lenguaje $L_{G_{S-SAT}}$
          que representa el lenguaje de todas las cadenas reconocidas por $G_{S-SAT}$, es necesario
          demostrar que $L_{S-SAT}=L_{G_{S-SAT}}$.

          Para demostrar que $L_{S-SAT}\subseteq L_{G_{S-SAT}}$, sea una fórmula booleana satisfacible $F$ y sea $q$ su representación como cadena en el lenguaje $L_{FULL-SAT}$,
          entonces existe una cadena binaria $w$, con longitud igual a la cantidad de variables de $F$, que satisface
          a $F$.

          Como $w$ satisface $F$ entonces $w$ pertenece al conjunto de cadenas que satisfacen a la primera
          cláusula de $F$. Esto significa que existe una secuencia de derivaciones desde el predicado $S(q)$
          hasta $B(z_q,w)$ y como $w$ satisface todas las cláusulas de $F$ entonces $B(z_q,w)$ deriva en la
          cadena vacía por lo que $q$ se reconoce por $G_{S-SAT}$, lo cual implica que $L_{S-SAT}\subseteq L_{G_{S-SAT}}$.

          Para completar la demostración es necesario demostrar que $ L_{G_{S-SAT}}\subseteq L_{S-SAT}$. Sea una cadena
          $q$ que se reconoce por $G_{S-SAT}$ y sea $F$ la fórmula booleana asociada a $q$, entonces existe una cadena
          binaria $w$ tal que existe una secuencia de derivaciones desde $A(q)$ a $B(z_q,w)$ y de $B(z_q,w)$ a la cadena vacía,
          por tanto $w$ satisface a la primera cláusula de $F$ y a las restantes también, luego $w$ satisface a $F$,
          por lo que $F$ es satisfacible. Esto implica que $L_{G_{S-SAT}}\subseteq L_{S-SAT}$ y con esto se demuestra que
          $L_{G_{S-SAT}}= L_{S-SAT}$.

\end{itemize}

En la siguiente sección se presentan un ejemplo del reconocimiento de una cadena por $G_{S-SAT}$.

\subsubsection{Ejemplo de reconocimiento de $G_{S-SAT}$}

En esta sección se presentan 2 ejemplos del funcionamiento de $G_{S-SAT}$ en el primero se muestra como se
reconoce la cadena asociada a la fórmula booleana $(x_1 \vee x_2) \wedge (x_1) \wedge (\neg x_2)$ y en el
segundo se muestra como no se reconoce la fórmula booleana asociada a $x_1 \wedge \neg x_1$.

La cadena asociada a $(x_1 \vee x_2) \wedge (x_1) \wedge (\neg x_2)$ es $aadacdcbd$, la secuencia de derivaciones
asociada a esta cadena en $G_{S-SAT}$ es la siguiente:

\begin{enumerate}
    \item $S(aadacdcbd)\to A(aadacdcbd)$: c-1, $X=aadacdcbd$
    \item $A(aadacdcbd)\to P(adacdcbd,1)$: c-2, $X=adacdcbd$
    \item $P(adacdcbd,1)\to P(dacdcbd,10)$: c-9, $X=dacdcbd$ $Y=1$
    \item $P(dacdcbd,10)\to B(acdcbd, 10)$: c-14, $X=acdcbd$ $Y=10$
    \item $B(acdcbd, 10)\to C(ac,10) B(cbd,10)$: c-21, $X_1=ac$ $X_2=cbd$ $Y=10$
    \item $B(cbd,10)\to C(cb,10) B(\varepsilon,10)$: c-21, $X_1=cb$ $X_2=\varepsilon$ $Y=10$
    \item $B(\varepsilon,10)\to \varepsilon$: c-22, $Y=10$
    \item $C(ac,10)\to Cn(ac,10)$: c-23, $X=ac$ $Y=10$
    \item $Cn(ac,10)\to Cp(c,0)$: c-24, $X=c$ $Y=0$
    \item $Cp(c,0)\to Cp(\varepsilon,\varepsilon)$: c-35, $X=\varepsilon$ $Y=\varepsilon$
    \item $Cp(\varepsilon, \varepsilon) \to \varepsilon$: c-36
    \item $C(cb,10)\to Cn(cb,10)$: c-23, $X=cb$ $Y=10$
    \item $Cn(cb,10)\to Cn(b,0)$: c-28, $X=b$ $Y=0$
    \item $Cn(b,0)\to Cp(\varepsilon,\varepsilon)$: c-27, $X=\varepsilon$ $Y=\varepsilon$
    \item $Cp(\varepsilon, \varepsilon) \to \varepsilon$: c-36
\end{enumerate}

Como todos los predicados derivan en la cadena vacía entonces $aadacdcbd$ se reconoce por $G_{S-SAT}$,
lo cual coincide con el hecho de que $(x_1 \vee x_2) \wedge (x_1) \wedge (\neg x_2)$, para la asignación
de valores $x_1=1$ y $x_2=0$.

Ahora se presenta un caso asociado a una fórmula que no es satisfacible y por tanto la cadena asociada
a dicha fórmula no se reconoce por $G_{S-SAT}$. La cadena asociada a $x_1 \wedge \neg x_1$ es $adbd$,
la secuencia de derivaciones asociada a esta cadena en $G_{S-SAT}$ es la siguiente:

\begin{enumerate}
    \item $S(adbd)\to A(adbd)$: c-1, $X=abdbd$
    \item $A(adbd)\to P(dbd,1)$: c-2, $X=dbd$
    \item $A(adbd)\to N(dbd,0)$: c-3, $X=dbd$
    \item $P(dbd,1) \to B(bd,1)$: c-14, $X=bd$ $Y=1$
    \item $B(bd,1)\to C(b,1) B(\varepsilon,1)$: c-21, $X_1=b$ $X_2=\varepsilon$ $Y=1$
    \item $C(b,1)\to Cn(b,1)$: c-23, $X=b$ $Y=1$
    \item $Cn(b,1)\to Cn(\varepsilon,\varepsilon)$: c-26, $X=\varepsilon$ $Y=\varepsilon$
\end{enumerate}

El predicado $C(b,1)$ en la quinta derivación no deriva en la cadena vacía por tanto, después de realizar
todas las posibles derivaciones y las sustituciones en rango $G_{S-SAT}$ no reconoce la cadena $adbd$.
Esto coincide con el hecho de que $x_1 \wedge \neg x_1$ no es satisfacible para ninguna asignación de
valores a sus variables.

Como $G_{S-SAT}$ reconoce las fórmulas booleanas satisfacibles solo se debe analizar el problema de la
palabra para determinar si una fórmula es satisfacible, por lo que el siguiente paso es analizar el la
complejidad del problema de la palabra para $G_{S-SAT}$.

\subsubsection{Análisis de la complejidad computacional del reconocimiento en $G_{S-SAT}$}

Como se mencionó en el capítulo 2 no todas las RCG tienen un algoritmo de reconocimiento polinomial y
$G_{S-SAT}$ es un ejemplo de ello. Observe que en la primera fase se genera la cadena binaria que representa
la asignación de valores a las variables booleanas y dicha cadena participa en los predicados de fases
posteriores, mediante las derivaciones de la gramática.

Si se analiza el algoritmo de reconocimiento descrito en \cite{mainRCGBib} un factor en la complejidad del
algoritmo de reconocimiento es la cantidad de rangos posibles para una cadena que se reconoce por un predicado.
En este caso la cadena que representa los valores de las variables de la fórmula booleana puede tomar $2^n$
valores distintos, donde $n$ es la cantidad de variables en la fórmula booleana, ya que dicha cadena se genera
durante la primera fase donde la gramática es ambigua y en cada derivación hay decisiones que generan valores
distintos.

Entonces como se pueden generar $2^n$ cadenas y cada cadena tiene $n^2$ rangos, luego la cantidad
de rangos totales sería $n^22^n$, pero esta es una cota burda ya que para cada cadena no se utilizan todos los
posibles rangos en el proceso de derivación de la gramática.

El resto de las fases de la gramática tienen una complejidad de $m^2$ donde $m$ es la cantidad de caracteres
en la cadena de entrada, por lo que la complejidad total sería $O(2^nm^2)$.

Este es resultado demuestra que no es necesario usar el transductor $T_{SAT}$ para definir el lenguaje
$L_{S-SAT}$, mediante un formalismo de escritura regulada.

En la siguiente sección se analiza una consecuencia directa del resultado de la gramática $G_{S-SAT}$, que demuestra
que las RCG reconocen todos los problemas de la clase NP.

\section{Clases de problemas que reconocen las RCG}

En \cite{propertiesRCGBib2} se menciona que para todo problema en P existe una RCG que lo reconoce en su
representación como lenguaje formal. Como se mostró en la sección anterior con la gramática $G_{S-SAT}$ existe
una RCG que permite resolver el SAT, por tanto como el SAT se puede reducir a cualquier problema en NP en una
complejidad polinomial, entonces para todo problema en NP también existe una RCG que lo reconoce en su
representación como lenguaje formal.

En la próxima sección se presenta un primer acercamiento para las instancias polinomiales del SAT, usando gramáticas de concatenación de rango
para determinar si una fórmula booleana asociada una de estas instancias polinomiales es satisfacible.

\section{Instancias de SAT polinomiales empleando RCG}

En esta sección se presenta una RCG que es capaz de reconocer problemas SAT, satisfacibles que pertenecen
al 2-SAT, es decir, problemas SAT donde cada cláusula tiene a lo sumo 2 literales. La idea detrás de esta
gramática es obtener una RCG que reconozca cuando la fórmula booleana pertenece al conjunto
de fórmulas booleanas de 2-SAT y luego intersectar dicha gramática con $G_{S-SAT}$.  Para ello se define la siguiente RCG:
\[
    G_{2-SAT} = (N, T, V, P, S),
\]
donde:

\begin{itemize}
    \item $N=\{S,A,A_0,A_1,A_2,A_3\}$
    \item $T=\{a,b,c,d\}$.
    \item $V=\{X,Y,X_1,X_2\}$.
    \item El conjunto de cláusulas $P$ es el siguiente:
          \begin{enumerate}
              \begin{multicols}{2}

                  \item $S(X)\to A(X)$
                  \item $A(X_1dX_2)\to A_0(X_1) A(X_2)$
                  \item $A(\varepsilon)\to \varepsilon$
                  \item $A_0(aX)\to A_1(X)$
                  \item $A_0(bX)\to A_1(X)$
                  \item $A_0(cX)\to A_0(X)$
                  \item $A_1(aX)\to A_2(X)$
                  \item $A_1(bX)\to A_2(X)$
                  \item $A_1(cX)\to A_1(X)$
                  \item $A_2(aX)\to A_3(X)$
                  \item $A_2(bX)\to A_3(X)$
                  \item $A_2(cX)\to A_2(X)$
                  \item $A_2(\varepsilon)\to \varepsilon$
              \end{multicols}
          \end{enumerate}
    \item El \textbf{símbolo inicial} es $S$.
\end{itemize}

El funcionamiento de la gramática anterior es el siguiente: la segunda cláusula permite reconocer todas las
cláusulas asociadas a la cadena original. Mientras que las cláusulas de la 4 a la 13 permiten contar
la cantidad de a o b en la cláusula (osea la cantidad de literales de cada cláusula), para esto se definen
4 estados: se reconocieron 0 a o b, se reconocieron una a o b, se reconocieron 2 a o b y se reconocen
más de 2 a o b, los cuales están representados por los predicados $A_0$, $A_1$, $A_2$ y $A_3$ respectivamente.
Se crean las derivaciones entre los predicados que representan cada estado y se deriva en la cadena vacía
desde el predicado $A_2$ cuando el argumento es la cadena vacía, lo que indica que la cláusula tiene 2 literales.


Como para todo problema en P existe una RCG que lo reconoce en su representación como lenguaje formal,
entonces es posible resolver las todas las instancias polinomiales del SAT usando gramáticas de
concatenación de rango.

Si se observa el enfoque seguido en la construcción de $G_{S-SAT}$, en la representación del SAT como cadena se
trabaja con una instancia del SAT general por lo que no se tienen en cuenta las propiedades específicas
del problema, que en el caso de las instancias polinomiales, es lo que permite que el algoritmo para las
misma sea polinomial.

Entonces la gramática que reconoce los problemas 2-SAT satisfacible sería:
$$G_{S-2-SAT}=G_{S-SAT}\cap G_{2-SAT}.$$
Pero $G_{S-2-SAT}$ el problema de la palabra para $G_{S-2-SAT}$ es exponencial y se conoce que para el 2-SAT
existe un algoritmo polinomial.

Como para todo problema en P existe una RCG que lo reconoce en su representación como lenguaje formal,
entonces es posible resolver el 2-SAT y todas las todas las instancias polinomiales del SAT usando gramáticas de
concatenación de rango. Pero no se ha podido encontrar una RCG que permita reconocer problemas 2-SAT satisfacibles
en un tiempo polinomial. Esto se prepone como problema abierto ya que puede conducir a encontrar otras instancias
de SAT solubles en tiempo polinomial.

En este capítulo se construyó el lenguaje $L_{S-SAT}$, mediante una RCG, lo que responde a la pregunta realizada en
el capítulo \ref{chap:LSATFT}, demostrando que no es necesario el transductor $T_{SAT}$ para definir $L_{S-SAT}$. Por otro
lado $G_{S-SAT}$ demuestra que todos los problemas en NP son reconocidos por una RCG y se presenta un primer acercamiento
para describir los problemas SAT polinomiales mediante un RCG, dejando abierto el problema de encontrar una RCG
que permita reconocer el 2-SAT y cuyo problema de la palabra sea polinomial.
