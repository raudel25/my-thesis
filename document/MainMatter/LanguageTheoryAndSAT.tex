\chapter{Solución polinomial de instancias del SAT usando Teoría de Lenguajes}

\section{Antecedentes}

Como parte del estudió del problema SAT, se han desarrollado una serie de trabajos utilizando un enfoque
novedoso basado en formalismos de la teoría de lenguajes, buscando resolver instancias específicas del SAT.

La idea principal abordada en \cite{aCFSAT} es transformar el SAT en una transformar una fórmula booleana en una lista de instancias de variables,
donde se asume que 2 instancias de una variable no tienen por qué tener el mismo valor de verdad. Luego
se define un autómata cuya construcción depende de la fórmula booleana, el funcionamiento
de dicho autómata se basa en dada una cadena de 0 y 1 determinar si se obtiene un valor
de verdad para la fórmula booleana donde cada instancia de una variable toma el valor de verdad que se
corresponde con la cadena de 0 y 1, dicho autómata se denomina \textbf{autómata booleano}.

\section{Autómata booleano}

Un autómata booleano \cite{aCFSAT} es un 6-tuplo $B=(Q,\Sigma,\delta,q_0,V,F)$ donde:

\begin{itemize}
      \item $Q$: Es un conjunto finito de \textbf{estados} (depende de la fórmula booleano asociada).
      \item $\Sigma$: Es el \textbf{alfabeto} finito de entrada, $\Sigma =\{0,1\}$.
      \item $\delta$: Es la \textbf{función de transición}, $\delta: Q \times \Sigma \to Q$, que define cómo el autómata cambia de estado en función del símbolo leído.
      \item $q_0 \in Q$: Es el \textbf{estado inicial} desde donde comienza la computación.
      \item  $V$: Estado final del autómata. Representa que la cadena de entrada es una
            cadena verdadera.
      \item  $F$: Es un estado distinguido del autómata, no es considerado estado final.
            Representa que la cadena de entrada es una cadena falsa.
            
\end{itemize}

\paragraph{Autómata booleano asociado a una variable:} el autómata booleano asociado a la instancia de una variable
se define como:

$$B=(\{q_0,V,F\},\{0,1\},\delta,q_0,V,F)$$

$$\delta(q_0,1)=V$$
$$\delta(q_0,0)=F$$

\paragraph{Autómata booleano asociado a la negación de una fórmula:} sea $A$ una fórmula booleana y $B$ el autómata booleano asociado a $A$ definido
como $B=(Q,\Sigma,\delta,q_0,V,F)$. Entonces el autómata booleano asociado $\not A$ se define como:

$$B=(Q,\Sigma,\delta,q_0,F,V)$$

\paragraph{Autómata booleano asociado a la disyunción de 2 fórmulas:} sean $A_1$ y $A_2$ fórmulas booleanas y
$B_1=(Q_1,\Sigma,\delta_1,q_1,V_1,F_1)$ y $B_2=(Q_2,\Sigma,\delta_2,q_2,V_2,F_2)$ los autómatas booleanos asociados a dicha fórmula. Entonces el autómata booleano asociado a
$A_1 \vee A_2$ se define como:

$$
      D=(Q_1\cup (Q_2-q_2),\Sigma,\delta,V_2, F_2)
$$
Ahora durante el reconocimiento de la cadena se tienen 2 casos:

\begin{enumerate}
      \item $B_1$ se evalúa positivo en este caso no es necesario que el autómata $B_2$ se evalué positivo, por lo
            que se añade una función $\overline{\delta}$ que consume una cantidad de caracteres igual a la cantidad
            de instancias de $A_2$ y termina en el estado $V_2$.
      \item $B_2$ se evalúa negativo en este caso es necesario que $B_2$ se evalué positivo, para ello se fusionan
            los estados $F_1$ y $q_2$ con el mismo estado y entonces el resultado de la evaluación de la cadena dependerá
            del estado final de $B_2$.
\end{enumerate}

\paragraph{Autómata booleano asociado a la conjunción de 2 fórmulas:} sean $A_1$ y $A_2$ fórmulas booleanas y
$B_1=(Q_1,\Sigma,\delta_1,q_1,V_1,F_1)$ y $B_2=(Q_2,\Sigma,\delta_2,q_2,V_2,F_2)$ los autómatas booleanos asociados a dicha fórmula. Entonces el autómata booleano asociado a
$A_1 \wedge A_2$ se define como:

$$
      D=(Q_1\cup (Q_2-q_2),\Sigma,\delta,V_2, F_2)
$$
Para que $A_1 \wedge A_2$ sea satisfacible por una cadena es necesario que tanto $B_1$ como $B_2$ se evaluen positivo, para
ello se fusionan los estados $V_1$ y $q_2$ como el mismo estado y entonces el resultado de la evaluación de la cadena dependerá
de los estados finales de $B_1$ y $B_2$ respectivamente.

\subsection{Construcción del autómata booleano asociado a una fórmula booleana}

Ahora dadas las definiciones anteriores es posible determinar el autómata booleano asociado a una fórmula booleana $A$ \cite{aCFSAT},
para ello primero se construyen los autómatas asociados a cada una de las instancias de variable que
aparecen en la secuencia. Una vez finalizada esta etapa se pasa a la concatenación de los
mismos teniendo en cuenta el siguiente orden.

\begin{enumerate}
      \item Efectuar las operaciones entre paréntesis.
      \item  Efectuar el operador negación.
      \item  Efectuar el operador conjunción.
      \item  Efectuar el operador disyunción.
\end{enumerate}

En \cite{aCFSAT} se demuestra que la cantidad de estados del autómata resultante es $O(n^2)$ donde $n$ es la cantidad de instancias
de variables de las fórmula $A$.

\subsubsection{Intersección con formalismos de escritura regulada}

Ahora el siguiente paso para determinar si la fórmula booleana es satisfacible es verificar
que la cadena de 0 y 1 que reconoce el autómata booleano asociado a dicha fórmula cumple que los caracteres
asociados a instancias de las mismas variables son iguales.

Para ello en \cite{aCFSAT} se propone imponer una restricción a la fórmula booleana en el orden en que aparecen sus
instancias de variables, dicho orden esta regido por un formalismo de escritura regulada. Luego para completar
el algoritmo se intersecta el autómata booleano con el formalismo seleccionado (dicho formalismo debe cumplir 2 propiedades:
ser cerrado bajo la intersección con lenguajes regulares y poder resolver el problema del vacío en tiempo polinomial), entonces
solo resta comprobar si el lenguaje generado por el formalismo es vacío o no.

Otro resultado interesante es encontrar un algoritmo que permita generar todas las posibles cadenas que pertenecen al lenguaje
generado por la intersección del autómata booleano y el formalismo de escritura regulada.

En las próximas secciones se presentarán los problemas SAT asociados a los trabajos que siguen el enfoque descrito anteriormente.

\section{Problema de la satisfacibilidad booleana libre del contexto}

El problema satisfacibilidad booleana libre del contexto (\textit{CF-SAT}) \cite{aCFSAT}, es una instancia específica
del SAT donde las variables donde la fórmula booleana es una fórmula booleana libre del contexto.

\paragraph{Fórmula booleana se considera libre del contexto:} una fórmula booleana se considera libre del contexto
\textit{CF-BF} si para cualquier par de instancias de una variable $x_i$ y $x_j$ con $i<j$ se
cumple que si existe otra variable con instancia $x_k$ con $i<k<j$ entonces todas las instancias de esta nueva
variable ocurren entre $x_i$ y $x_j$.

Dada la definición anterior posible clasificar las instancias de cada variable en una fórmula booleana:

\begin{enumerate}
      \item \textbf{Clase libre:} a esta clase pertenecen todas las instancias de las variables que ocurren
            una única vez en la fórmula booleana.
      \item \textbf{Clase primera:} a esta clase pertenecen todas las instancias que representan la primera
            ocurrencia de una variable en la fórmula booleana (la variable debe ocurrir más de una vez).
      \item \textbf{Clase intermedia:} a esta clase pertenecen todas las instancias que no representan ni la primera, ni la última
            ocurrencia de una variable en la fórmula booleana (la variable debe ocurrir más de una vez).
      \item \textbf{Clase última:} a esta clase pertenecen todas las instancias que representan la última
            ocurrencia de una variable en la fórmula booleana (la variable debe ocurrir más de una vez).
\end{enumerate}

\subsection{Solución al CF-SAT}

El orden que siguen las instancias de las variables en una CF-BF puede ser reconocido por una CFG que a su vez trae asociado
un autómata de pila, al cual de le denomina autómata de pila booleano \cite{aCFSAT}.

Ahora para la construcción del autómata de pila booleano correspondiente a una CF-BF se toma el autómata booleano definido en
la sección anterior y se le añade un mecanismo de memoria. Dicho mecanismo de memoria funciona de la siguiente manera:

\begin{itemize}
      \item Si el caracter analizado corresponde a una instancia de clase libre, dicho caracter no se almacena en la pila.
      \item Si el caracter analizado corresponde a una instancia de clase primera, dicho caracter se almacena en la pila.
      \item Si el caracter analizado corresponde a una instancia de clase intermedia, dicho caracter no se almacena en la
            pila y se comprueba que su valor sea igual al del tope de la pila.
      \item Si el caracter analizado corresponde a una instancia de clase última, dicho caracter no se almacena en la
            pila, se comprueba que su valor sea igual al del tope de la pila y se retira el valor del tope de la pila.
\end{itemize}
Luego el autómata de pila booleano reconoce una cadena si termina en un estado final con la pila vacía.

En \cite{aCFSAT} se describe como dado un autómata de pila encontrar la CFL correspondiente y luego enuncia un
algoritmo que permite determinar si el lenguaje generado con por la gramática es vacío o no y un algoritmo para
generar todas las cadenas que pertenecen a dicha gramática. Este algoritmo tiene una complejidad de $O(n^3)$, donde $n$
es la cantidad de instancias de variables en la CF-BF.

\section{Problema de la satisfacibilidad booleana de concatenación de rango simple}

Una secuencia de instancias de variables de longitud $n$ tiene un orden de concatenación de rango simple \cite{aSRCSAT},
si es posible construir una SRCG, con un tamaño polinomial en $n$, que genere el lenguaje de todas las cadenas
$w_1w_2 \ldots w_n$, de longitud $n$ sobre el alfabeto {0,1}, tal que para todo par de instancias de variables
($x_i$, $x+j$) que pertenezcan a la misma variable se cumple que $w_i = w_j$.

El problema de la satisfacibilidad booleana de concatenación de rango simple (\textit{SRC-SAT}) es una instancia de
SAT donde la secuencia de instancias de sus variables posee un orden de concatenación de rango simple.

\subsection{Solución al SRC-SAT}

Para la solución del SRC-SAT en \cite{aSRCSAT} se procede de manera similar a \cite{aCFSAT}, pero esta vez el autómata
booleano se intersecta con una SRCG que describe el orden de la fórmula booleana.

Luego solo queda resolver el problema del vacío para el formalismo resultante, para esto se obtiene una CFG
que representa el lenguaje de todas las posibles formas de generar la menor cadena en la intersección de la SRCG
con autómata booleano y solo queda verificar que dicha CFG sea no vacía como se muestra en \cite{aCFSAT}. La complejidad
de todo este proceso es $O(n^k)$ donde $n$ es el número de instancias de variables en la fórmula booleana y $k$ es
la aridad de la SRCG.

El SRC-SAT constituye un paso de avance en cuanto al CF-SAT ya que describe un espacio mucho más amplio de instancias de SAT
que pueden ser resueltas en un tiempo polinomial.

\section{Primera aproximación a la solución del SAT usando gramáticas matriciales simples}

En \cite{aSMSAT} se propone un nuevo enfoque a los 2 problemas anteriores, el cual se basa en eliminar la restricción
de la estructura de la fórmula booleana y en su lugar se trabaja con una representación diferente de la misma.

Dada un fórmula booleana en CNF con $n$ variables distintas y $m$ cláusulas en \cite{aSMSAT} se propone una representación de la misma
en una secuencia de cláusulas (definiendo una misma secuencia de variables para cada cláusula) donde cada variable tiene
3 posibles estados $a$, $b$ y $c$ que representan si la variable esta positiva, negada o no pertenece a la cláusula
respectivamente. Con esta nueva estructura se modifica el autómata booleano correspondiente a dicha fórmula para que trabaje con
cadenas que pertenezcan al lenguaje $L^n_m=\{w^m\,|\,w\in\{0,1\} \wedge |w|=n\}$, observe que $w$ se puede interpretar como una
asignación de valores para cada una de las variables.

\subsection{Lenguaje $L^n_m$}

En \cite{aSMSAT} se define una gramática matricial simple que describe el lenguaje $L^n_m$:

$$
      G_n=(\{A_1,A_{11},\ldots A_{1m}\},\ldots,\{A_n,A_{n1},\ldots A_{nm}\},\Sigma,P,S,\Sigma)
$$
donde:
\begin{itemize}
      \item \( \Sigma \) =$\{0,1\}$.
      \item \( P \) es un conjunto finito de matrices de producciones:
            \begin{itemize}
                  \item  $[S \to A_1A_2\ldots A_n]$
                  \item  $[A_1 \to 1A_{12}, \ldots, A_n \to 1A_{n2}]$
                  \item  $[A_1 \to 0A_{12}, \ldots, A_n \to 0A_{n2}]$
                  \item  Para $2 \leq i < m$, $[A_{1i} \to 1A_{1(i+1)}, \ldots, A_{ni} \to 1A_{n(i + 1)}]$
                  \item  Para $2 \leq i < m$, $[A_{1i} \to 0A_{1(i+1)}, \ldots, A_{ni} \to 0A_{n(i + 1)}]$
                  \item  $[A_{1m} \to 1, ldots, A_{nm} \to 1]$
                  \item  $[A_{1m} \to 0, ldots, A_{nm} \to 0]$
            \end{itemize}
      \item \( S \) es el \textbf{símbolo inicial}.
\end{itemize}

\subsection{Intersección con el autómata booleano}

En \cite{aSMSAT} se menciona que las $n-SMG$ son cerradas bajo la intersección con lenguajes regulares, pero sin embargo
cuando se analiza la intersección del autómata con la $n-SMG$ que describe el lenguaje $L^n_m$ se obtiene una gramática
con una cantidad de producciones exponencial en relación a la cantidad de variables de la fórmula booleana, lo cual impide
analizar si el lenguaje resultante es vacío en un tiempo polinomial.
